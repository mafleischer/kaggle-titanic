{"cells":[{"metadata":{"trusted":true},"cell_type":"code","source":"import numpy as np\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nimport seaborn as sns\nimport pandas as pd\nimport os\n\nfrom sklearn.base import BaseEstimator, TransformerMixin\nfrom sklearn.linear_model import LinearRegression, SGDClassifier, LogisticRegression\nfrom sklearn.svm import LinearSVC, SVC\nfrom sklearn.tree import DecisionTreeClassifier\nfrom sklearn.ensemble import RandomForestClassifier, VotingClassifier, AdaBoostClassifier, GradientBoostingClassifier, BaggingClassifier\nfrom sklearn.model_selection import StratifiedShuffleSplit, StratifiedKFold, cross_val_score, cross_val_predict ,GridSearchCV\nfrom sklearn.model_selection import validation_curve, learning_curve\nfrom sklearn.preprocessing import OneHotEncoder, StandardScaler, PolynomialFeatures\nfrom sklearn.impute import SimpleImputer\nfrom sklearn.compose import ColumnTransformer\nfrom sklearn.pipeline import make_pipeline, Pipeline\nfrom sklearn.metrics import mean_squared_error, accuracy_score, confusion_matrix, precision_recall_curve, plot_precision_recall_curve\nfrom sklearn.metrics import precision_score, recall_score, roc_curve, roc_auc_score\n\nsns.set()\n\n# This checks if the notebook is executed on Kaggle or on your local machine and\n# acts accordingly with filenames.\nfname_train = \"train.csv\"\nfname_test = \"test.csv\"\n\ntry:\n    os.environ['KAGGLE_DATA_PROXY_TOKEN']\nexcept KeyError:\n    pass\nelse:\n    dirname = \"/kaggle/input/titanic/\"\n    fname_train = dirname + fname_train\n    fname_test = dirname + fname_test","execution_count":7,"outputs":[]},{"metadata":{},"cell_type":"markdown","source":"# \"What do we have here?\""},{"metadata":{"trusted":true},"cell_type":"code","source":"titanic = pd.read_csv(fname_train)\ntitanic.info()","execution_count":8,"outputs":[{"output_type":"stream","text":"<class 'pandas.core.frame.DataFrame'>\nRangeIndex: 891 entries, 0 to 890\nData columns (total 12 columns):\n #   Column       Non-Null Count  Dtype  \n---  ------       --------------  -----  \n 0   PassengerId  891 non-null    int64  \n 1   Survived     891 non-null    int64  \n 2   Pclass       891 non-null    int64  \n 3   Name         891 non-null    object \n 4   Sex          891 non-null    object \n 5   Age          714 non-null    float64\n 6   SibSp        891 non-null    int64  \n 7   Parch        891 non-null    int64  \n 8   Ticket       891 non-null    object \n 9   Fare         891 non-null    float64\n 10  Cabin        204 non-null    object \n 11  Embarked     889 non-null    object \ndtypes: float64(2), int64(5), object(5)\nmemory usage: 83.7+ KB\n","name":"stdout"}]},{"metadata":{"trusted":true},"cell_type":"code","source":"titanic.head()","execution_count":null,"outputs":[]},{"metadata":{"trusted":true},"cell_type":"code","source":"# Pretend we already know for sure that these are unimportant:\nunnecessary = [\"PassengerId\", \"Name\",\"SibSp\",\"Parch\",\"Ticket\", \"Cabin\", \"Embarked\"]\n#unnecessary = [\"PassengerId\", \"Name\",\"Ticket\", \"Embarked\"]\nunnecessary = [\"PassengerId\", \"Name\",\"Ticket\", \"Embarked\", \"Cabin\"]\n\ntitanic.drop(unnecessary, inplace=True, axis=1)\ntitanic","execution_count":null,"outputs":[]},{"metadata":{"trusted":true},"cell_type":"code","source":"titanic.isnull().any()","execution_count":null,"outputs":[]},{"metadata":{},"cell_type":"markdown","source":"## Quickly figure out how to fill the missing values"},{"metadata":{"trusted":true},"cell_type":"code","source":"sns.distplot(titanic.Age, norm_hist=False, kde=False)","execution_count":null,"outputs":[]},{"metadata":{"trusted":true},"cell_type":"code","source":"titanic.Age.fillna(titanic.Age.mean(), inplace=True)","execution_count":null,"outputs":[]},{"metadata":{"trusted":true},"cell_type":"code","source":"fig, ax = plt.subplots(1, 1, figsize=(10,10))\ntitanic[\"Fare_cat\"] = pd.cut(titanic[\"Fare\"], bins = 7)\nsns.countplot(data=titanic, x = \"Fare_cat\", hue = \"Survived\", ax = ax)","execution_count":null,"outputs":[]},{"metadata":{"trusted":true},"cell_type":"code","source":"fig, ax = plt.subplots(1, 1, figsize=(10,10))\ntitanic[\"Age_cat\"] = pd.cut(titanic[\"Age\"].astype(int), bins = 4)\nsns.countplot(data=titanic, x = \"Age_cat\", hue = \"Survived\", ax = ax)","execution_count":null,"outputs":[]},{"metadata":{},"cell_type":"markdown","source":"# Make Pipelines"},{"metadata":{"trusted":true},"cell_type":"code","source":"class CabinLetterOnly(BaseEstimator, TransformerMixin):\n    def __init__(self):\n        pass\n    def fit(self, X, y = None):\n        return self\n    def transform(self, X):\n        df = pd.DataFrame(X, index=titanic.index, columns=titanic.columns)\n        s_cabin_letters = df.Cabin.str.extract(\"^([A-Z]).*\", expand = False)\n        return np.c_[df.to_numpy(), s_cabin_letters]\n\nsex_pip = Pipeline([\n    ('one_hot', OneHotEncoder(categories=[titanic.Sex]))\n])\n\nfare_pip = Pipeline([\n    (\"fare_mean\", SimpleImputer(strategy=\"mean\")),\n    ('fare_std', StandardScaler())\n])\n\npclass_pip = Pipeline([\n    ('pclass_std', StandardScaler())\n])\n\nage_pip = Pipeline([\n    ('age_std', StandardScaler())\n])\n\nparch_pip = Pipeline([\n    ('parch_std', StandardScaler())\n])\n\nsibsp_pip = Pipeline([\n    ('sibsp_std', StandardScaler())\n])\n\nadd_attrs = Pipeline([\n    (\"cabin_fill\", SimpleImputer(strategy=\"most_frequent\")),\n    (\"add_cabin_letters\", CabinLetterOnly())\n])\n\n# new = add_attrs.fit_transform(titanic.values)\n# titanic = pd.DataFrame(new, index=titanic.index, columns=titanic.columns.union(pd.Index([\"Cabin_letter\"]), sort=False))\n# titanic.drop([\"Cabin\"], axis=1, inplace=True)\n\n# cabin_pip = Pipeline([\n#     ('cabin_1hot', OneHotEncoder(categories=[titanic.Cabin_letter]))\n# ])\n\nattr_pip = ColumnTransformer([\n    #(\"passthrough\", \"passthrough\", [\"Pclass\"]),\n    (\"pclass\", pclass_pip, [\"Pclass\"]),\n    (\"sex\", sex_pip, [\"Sex\"]),\n    (\"fare\", fare_pip, [\"Fare\"]),\n    (\"age\", fare_pip, [\"Age\"]),\n    (\"parch\", parch_pip, [\"Parch\"]),\n    (\"sibsp\", sibsp_pip, [\"SibSp\"]),\n    #(\"cabin_add\", add_attrs, [\"Cabin\"]),\n    #(\"cabin_trans\", cabin_pip, [\"Cabin_letter\"]),\n], remainder=\"drop\")\n\n\n### models ###\n\nlin_reg_pip = Pipeline([\n    (\"attr_pip\", attr_pip),\n    ('lin_reg', LinearRegression())\n])\n\nlog_reg_pip = Pipeline([\n    (\"attr_pip\", attr_pip),\n    ('log_reg', LogisticRegression(multi_class=\"multinomial\"))\n])\n\nsgd_clf_pip = Pipeline([\n    (\"attr_pip\", attr_pip),\n    ('sgd_clf', SGDClassifier(random_state=42))\n])\n\ndectree_clf_pip = Pipeline([\n    (\"attr_pip\", attr_pip),\n    ('dec_tree', DecisionTreeClassifier(random_state=42))\n])\n\nrndforest_clf_pip = Pipeline([\n    (\"attr_pip\", attr_pip),\n    ('rnd_forest', RandomForestClassifier(random_state=42))\n])\n\nlin_svc_pip = Pipeline([\n    (\"attr_pip\", attr_pip),\n    ('lin_svc', LinearSVC(C = 10, loss = \"hinge\"))\n])\n\nsvc_pip = Pipeline([\n    (\"attr_pip\", attr_pip),\n    ('lin_svc', SVC(C = 10))\n])","execution_count":null,"outputs":[]},{"metadata":{},"cell_type":"markdown","source":"# Create train and dev test sets now to avoid data snooping bias"},{"metadata":{"trusted":true},"cell_type":"code","source":"split = StratifiedShuffleSplit(n_splits=1, test_size=0.1, random_state=42)","execution_count":null,"outputs":[]},{"metadata":{},"cell_type":"markdown","source":"## Stratify on Pclass column for now. Maybe there is better."},{"metadata":{"trusted":true},"cell_type":"code","source":"for train_ix, test_ix in split.split(titanic, titanic[\"Sex\"]):\n    strat_train = titanic.loc[train_ix]\n    strat_devtest = titanic.loc[test_ix]","execution_count":null,"outputs":[]},{"metadata":{},"cell_type":"markdown","source":"# What is worth including in the classification?"},{"metadata":{"trusted":true},"cell_type":"code","source":"pd.get_dummies(strat_train).corr()","execution_count":null,"outputs":[]},{"metadata":{},"cell_type":"markdown","source":"## --> Include Pclass, Fare and Sex into classification"},{"metadata":{"trusted":true},"cell_type":"code","source":"#strat_train.drop([\"Age\"], inplace=True, axis=1)","execution_count":null,"outputs":[]},{"metadata":{},"cell_type":"markdown","source":"# Inspect further"},{"metadata":{"trusted":true},"cell_type":"code","source":"fig, ax = plt.subplots(1, 2, sharey=True, figsize = (5,5))\nsns.countplot(x=\"Survived\", data=strat_train, ax = ax[0], palette = \"RdGy\")\nsns.countplot(x=\"Survived\", hue=\"Sex\", data=strat_train, ax = ax[0], palette = \"BuPu\")\nsns.countplot(x=\"Survived\", data=strat_train, ax = ax[1], palette = \"RdGy\")\nsns.countplot(x=\"Survived\", hue=\"Pclass\", data=strat_train, ax = ax[1], palette=\"cividis\")","execution_count":null,"outputs":[]},{"metadata":{"trusted":true},"cell_type":"code","source":"g = sns.FacetGrid(col=\"Sex\", row=\"Pclass\", data=strat_train)\ng.map_dataframe(sns.countplot, \"Survived\")","execution_count":null,"outputs":[]},{"metadata":{},"cell_type":"markdown","source":"# Labels"},{"metadata":{"trusted":true},"cell_type":"code","source":"titanic_labels = titanic[\"Survived\"].astype(int)\nstrat_train_labels = strat_train[\"Survived\"].astype(int)\nstrat_devtest_labels = strat_devtest[\"Survived\"].astype(int)\nstrat_train.drop(\"Survived\", inplace=True, axis=1)\nstrat_devtest.drop(\"Survived\", inplace=True, axis=1)","execution_count":null,"outputs":[]},{"metadata":{},"cell_type":"markdown","source":"# Consider Models"},{"metadata":{},"cell_type":"markdown","source":"## Coarse try"},{"metadata":{"trusted":true},"cell_type":"code","source":"# lin_reg_pip.fit(strat_train, strat_train_labels)\n# pred = lin_reg_pip.predict(strat_train)\n# accuracy_score(strat_train_labels, pred)","execution_count":null,"outputs":[]},{"metadata":{"trusted":true},"cell_type":"code","source":"log_reg_pip.fit(strat_train, strat_train_labels)\npred = log_reg_pip.predict(strat_train)\naccuracy_score(strat_train_labels, pred)","execution_count":null,"outputs":[]},{"metadata":{"trusted":true},"cell_type":"code","source":"sgd_clf_pip.fit(strat_train, strat_train_labels)\npred = sgd_clf_pip.predict(strat_train)\naccuracy_score(strat_train_labels, pred)","execution_count":null,"outputs":[]},{"metadata":{"trusted":true},"cell_type":"code","source":"rndforest_clf_pip.fit(strat_train, strat_train_labels)\npred = rndforest_clf_pip.predict(strat_train)\naccuracy_score(strat_train_labels, pred)","execution_count":null,"outputs":[]},{"metadata":{"trusted":true},"cell_type":"code","source":"dectree_clf_pip.fit(strat_train, strat_train_labels)\npred = dectree_clf_pip.predict(strat_train)\naccuracy_score(strat_train_labels, pred)","execution_count":null,"outputs":[]},{"metadata":{"trusted":true},"cell_type":"code","source":"lin_svc_pip.fit(strat_train, strat_train_labels)\npred = lin_svc_pip.predict(strat_train)\naccuracy_score(strat_train_labels, pred)","execution_count":null,"outputs":[]},{"metadata":{"trusted":true},"cell_type":"code","source":"svc_pip.fit(strat_train, strat_train_labels)\npred = svc_pip.predict(strat_train)\n\naccuracy_score(strat_train_labels, pred)","execution_count":null,"outputs":[]},{"metadata":{},"cell_type":"markdown","source":"# Random Forest"},{"metadata":{},"cell_type":"markdown","source":"## Try various hyper params"},{"metadata":{"trusted":true},"cell_type":"code","source":"strat_train_prep = attr_pip.fit_transform(strat_train)\nstrat_devtest_prep = attr_pip.fit_transform(strat_devtest)\nrnd_forest = RandomForestClassifier(random_state=42)\n# don't know if skfold actually makes sense here\nskfold = StratifiedKFold(n_splits=15)\ncross_val_score(rnd_forest, strat_train_prep, strat_train_labels, cv = skfold, scoring=\"accuracy\")","execution_count":null,"outputs":[]},{"metadata":{"trusted":true},"cell_type":"code","source":"n_estimators_range = np.arange(1,10)\ntrain_scores, test_scores = validation_curve(rnd_forest, strat_train_prep, strat_train_labels, param_name=\"n_estimators\", param_range=n_estimators_range, scoring=\"accuracy\", cv = skfold)\nplt.plot(n_estimators_range, np.mean(train_scores, 1), label=\"train score\", c='b')\nplt.plot(n_estimators_range, np.mean(test_scores, 1), label=\"test score\", c='r')","execution_count":null,"outputs":[]},{"metadata":{},"cell_type":"markdown","source":"### ---> Looks like bad overfitting"},{"metadata":{"trusted":true},"cell_type":"code","source":"param_grid = [\n    {\"random_state\" : [42], \"max_features\" : [1,2,3,4], \"max_depth\" : [2,3,4], \"n_estimators\" : [50, 100],\n    \"min_samples_split\" : [3,4], \"min_samples_leaf\" : [3,4], \"min_impurity_decrease\" : [0.0, 0.1]}\n]\n\ngridsearch = GridSearchCV(rnd_forest, param_grid = param_grid, cv = skfold, scoring=\"accuracy\", return_train_score=False)\ngridsearch.fit(strat_train_prep, strat_train_labels)\nbest_rnd_forest = gridsearch.best_estimator_","execution_count":null,"outputs":[]},{"metadata":{"trusted":true},"cell_type":"code","source":"best_rnd_forest","execution_count":null,"outputs":[]},{"metadata":{"trusted":true},"cell_type":"code","source":"pred_scores = cross_val_predict(best_rnd_forest, strat_train_prep, strat_train_labels, cv = skfold, method=\"predict_proba\")\nprecisions, recalls, thresholds = precision_recall_curve(strat_train_labels, pred_scores[:, 1])\n\nsns.lineplot(thresholds, precisions[:-1], color=\"r\")\nsns.lineplot(thresholds, recalls[:-1], color=\"b\")","execution_count":null,"outputs":[]},{"metadata":{"trusted":true},"cell_type":"code","source":"plot_precision_recall_curve(best_rnd_forest, strat_train_prep, strat_train_labels, response_method=\"predict_proba\")","execution_count":null,"outputs":[]},{"metadata":{"trusted":true},"cell_type":"code","source":"pred_scores = cross_val_predict(best_rnd_forest, strat_devtest_prep, strat_devtest_labels, cv = skfold, method=\"predict_proba\")\nprecisions, recalls, thresholds = precision_recall_curve(strat_devtest_labels, pred_scores[:, 1])\n\nsns.lineplot(thresholds, precisions[:-1], color=\"r\")\nsns.lineplot(thresholds, recalls[:-1], color=\"b\")","execution_count":null,"outputs":[]},{"metadata":{"trusted":true},"cell_type":"code","source":"pred_scores = cross_val_predict(rndforest_clf_pip, strat_devtest, strat_devtest_labels, cv = skfold, method=\"predict_proba\")\nprecisions, recalls, thresholds = precision_recall_curve(strat_devtest_labels, pred_scores[:, 1])\n\nsns.lineplot(thresholds, precisions[:-1], color=\"r\")\nsns.lineplot(thresholds, recalls[:-1], color=\"b\")","execution_count":null,"outputs":[]},{"metadata":{"trusted":true},"cell_type":"code","source":"pred = best_rnd_forest.predict(strat_devtest_prep)\nconfusion_matrix(strat_devtest_labels, pred)","execution_count":null,"outputs":[]},{"metadata":{"trusted":true},"cell_type":"code","source":"pred = rndforest_clf_pip.predict(strat_devtest)\nconfusion_matrix(strat_devtest_labels, pred)","execution_count":null,"outputs":[]},{"metadata":{"trusted":true},"cell_type":"code","source":"thresh = 0.65\ncustom_thresh_preds = pred_scores > thresh\nprecisions, recalls, thresholds = precision_recall_curve(strat_devtest_labels, custom_thresh_preds[:, 1])\n\nsns.lineplot(thresholds, precisions[:-1], color=\"r\")\nsns.lineplot(thresholds, recalls[:-1], color=\"b\")","execution_count":null,"outputs":[]},{"metadata":{"trusted":true},"cell_type":"code","source":"confusion_matrix(strat_devtest_labels, custom_thresh_preds[:,1])","execution_count":null,"outputs":[]},{"metadata":{"trusted":true},"cell_type":"code","source":"# pred = best_rnd_forest.predict(strat_devtest_prep)\n# accuracy_score(strat_devtest_labels, pred)","execution_count":null,"outputs":[]},{"metadata":{},"cell_type":"markdown","source":"# Polynomial SVC"},{"metadata":{"trusted":true},"cell_type":"code","source":"# poly_features = PolynomialFeatures(degree = 3)\n# train_poly = poly_features.fit_transform(strat_train_prep)\n# test_poly = poly_features.fit_transform(strat_devtest_prep)\n\n# linsvc = LinearSVC(C=5, loss=\"hinge\", max_iter=2000, random_state=42)\n# linsvc.fit(train_poly, strat_train_labels)\n# pred = linsvc.predict(test_poly)\n\n# accuracy_score(strat_devtest_labels, pred)","execution_count":null,"outputs":[]},{"metadata":{"trusted":true},"cell_type":"code","source":"# C = [5,10]\n# train_scores, test_scores = validation_curve(linsvc, train_poly, strat_train_labels, param_name=\"C\", param_range=C, scoring=\"accuracy\", cv = skfold)\n# plt.plot(C, np.mean(train_scores, 1), label=\"train score\", c='b')\n# plt.plot(C, np.mean(test_scores, 1), label=\"test score\", c='r')\n","execution_count":null,"outputs":[]},{"metadata":{"trusted":true},"cell_type":"code","source":"svc = SVC(random_state=42, probability=True)","execution_count":null,"outputs":[]},{"metadata":{"trusted":true},"cell_type":"code","source":"param_grid = [\n    {\"random_state\" : [42], \"C\" : [2,3,4,5,10], \"kernel\" : [\"poly\"], \"degree\" : [1,2,3,4],\n    \"coef0\" : [1,2,3,4]}\n]\n\ngridsearch = GridSearchCV(svc, param_grid = param_grid, cv = skfold, scoring=\"accuracy\", return_train_score=False)\ngridsearch.fit(strat_train_prep, strat_train_labels)\nbest_svc = gridsearch.best_estimator_","execution_count":null,"outputs":[]},{"metadata":{"trusted":true},"cell_type":"code","source":"pred_scores = cross_val_predict(best_svc, strat_train_prep, strat_train_labels, cv = skfold, method=\"decision_function\")\nprecisions, recalls, thresholds = precision_recall_curve(strat_train_labels, pred_scores)\n\nsns.lineplot(thresholds, precisions[:-1], color=\"r\")\nsns.lineplot(thresholds, recalls[:-1], color=\"b\")","execution_count":null,"outputs":[]},{"metadata":{"trusted":true},"cell_type":"code","source":"plot_precision_recall_curve(best_svc, strat_train_prep, strat_train_labels, response_method=\"decision_function\")","execution_count":null,"outputs":[]},{"metadata":{"trusted":true},"cell_type":"code","source":"pred = best_svc.predict(strat_devtest_prep)\nconfusion_matrix(strat_devtest_labels, pred)","execution_count":null,"outputs":[]},{"metadata":{"trusted":true},"cell_type":"code","source":"# strat_devtest_prep = attr_pip.fit_transform(strat_devtest)\n# pred = best_svc.predict(strat_devtest_prep)\n# accuracy_score(strat_devtest_labels, pred)","execution_count":null,"outputs":[]},{"metadata":{"trusted":true},"cell_type":"code","source":"# best_svc.fit(strat_train_prep, strat_train_labels)\n# pred = best_svc.predict(strat_train_prep)\n\n# accuracy_score(strat_train_labels, pred)","execution_count":null,"outputs":[]},{"metadata":{},"cell_type":"markdown","source":"# Logistic Regression"},{"metadata":{"trusted":true},"cell_type":"code","source":"log_reg = LogisticRegression(multi_class=\"multinomial\", solver=\"lbfgs\")\n#log_reg.fit(strat_train_prep, strat_train_labels)\n#best_log_reg = log_reg","execution_count":null,"outputs":[]},{"metadata":{"trusted":true},"cell_type":"code","source":"param_grid = [\n    {\"C\" : [1,2,3,4,5,6,7], \"max_iter\" : [100, 200], \"fit_intercept\" : [True, False]}\n]\n\ngridsearch = GridSearchCV(log_reg, param_grid = param_grid, cv = skfold, scoring=\"accuracy\", return_train_score=False)\ngridsearch.fit(strat_train_prep, strat_train_labels)\nbest_log_reg = gridsearch.best_estimator_","execution_count":null,"outputs":[]},{"metadata":{"trusted":true},"cell_type":"code","source":"pred_scores = cross_val_predict(best_log_reg, strat_train_prep, strat_train_labels, cv = skfold, method=\"decision_function\")\nprecisions, recalls, thresholds = precision_recall_curve(strat_train_labels, pred_scores)\n\nsns.lineplot(thresholds, precisions[:-1], color=\"r\")\nsns.lineplot(thresholds, recalls[:-1], color=\"b\")","execution_count":null,"outputs":[]},{"metadata":{"trusted":true},"cell_type":"code","source":"pred = best_log_reg.predict(strat_devtest_prep)\nconfusion_matrix(strat_devtest_labels, pred)","execution_count":null,"outputs":[]},{"metadata":{},"cell_type":"markdown","source":"# Ensemble"},{"metadata":{"trusted":true},"cell_type":"code","source":"# voting_clf = VotingClassifier(\n#     estimators=[(\"rf\", best_rnd_forest), (\"dt\", best_dec_tree), (\"svc\", best_svc), (\"log\", LogisticRegression())], voting=\"soft\"\n# )\n\n# # voting_clf = VotingClassifier(\n# #     estimators=[(\"rf\", RandomForestClassifier(random_state=42)), (\"dt\", LogisticRegression()), (\"svc\", SVC(C = 10, probability=True))], voting=\"soft\"\n# # )\n\n\n# voting_clf.fit(strat_train_prep, strat_train_labels)\n\n# pred = voting_clf.predict(strat_devtest_prep)\n# accuracy_score(strat_devtest_labels, pred)","execution_count":null,"outputs":[]},{"metadata":{"trusted":true},"cell_type":"code","source":"# ada_clf = AdaBoostClassifier(voting_clf, algorithm=\"SAMME.R\", learning_rate=0.5)\n# ada_clf.fit(strat_train_prep, strat_train_labels)\n\n# pred = ada_clf.predict(strat_devtest_prep)\n# accuracy_score(strat_devtest_labels, pred)","execution_count":null,"outputs":[]},{"metadata":{"trusted":true},"cell_type":"code","source":"# bag_clf = BaggingClassifier(voting_clf, bootstrap=True)\n\n# bag_clf.fit(strat_train_prep, strat_train_labels)\n\n# pred = bag_clf.predict(strat_devtest_prep)\n# accuracy_score(strat_devtest_labels, pred)","execution_count":null,"outputs":[]},{"metadata":{},"cell_type":"markdown","source":"# Predict test set"},{"metadata":{"trusted":true},"cell_type":"code","source":"#best_model = RandomForestClassifier(random_state=42)\nbest_model = best_rnd_forest\n#best_model = ada_clf\n# best_model = voting_clf\n# best_model = best_svc","execution_count":null,"outputs":[]},{"metadata":{"trusted":true},"cell_type":"code","source":"full_train = titanic.drop(\"Survived\", axis=1)\nfull_train_prep = attr_pip.fit_transform(full_train)\nbest_model.fit(full_train_prep, titanic_labels)\n\ntest = pd.read_csv(fname_test)\ntest_prep = attr_pip.fit_transform(test)\ntitanic_prep = attr_pip.fit_transform(titanic)\n\n#sgd_clf.fit(titanic_prep, titanic_labels)\n#survival_pred = sgd_clf.predict(test_prep)\n\nsurvival_pred = best_model.predict(test_prep)\n\n\nsurvival_proba = best_model.predict_proba(test_prep)\nsurvival_pred = survival_proba > thresh\nsurvival_pred = survival_pred[:, 1].astype(int)\n\n\nsurvival_pred = pd.DataFrame(survival_pred, columns=[\"Survived\"])\n\nid_survival = pd.concat([test.PassengerId, survival_pred], axis=1)\nid_survival.set_index(\"PassengerId\", inplace=True)\nid_survival.to_csv(\"predicition.csv\")\nid_survival","execution_count":null,"outputs":[]}],"metadata":{"kernelspec":{"display_name":"Python 3","language":"python","name":"python3"},"language_info":{"codemirror_mode":{"name":"ipython","version":3},"file_extension":".py","mimetype":"text/x-python","name":"python","nbconvert_exporter":"python","pygments_lexer":"ipython3","version":"3.7.4"}},"nbformat":4,"nbformat_minor":4}